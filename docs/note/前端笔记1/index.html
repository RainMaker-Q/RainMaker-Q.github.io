<!doctype html>
<html lang="zh-cn" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Rain-Maker的成长之路 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Rain-Maker的成长之路 Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Rain-Maker的成长之路" href="/opensearch.xml"><title data-react-helmet="true">前端笔记(合集) | Rain-Maker的成长之路</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://lrqwriting.top/docs/note/前端笔记1"><meta data-react-helmet="true" name="docsearch:language" content="zh-cn"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="前端笔记(合集) | Rain-Maker的成长之路"><meta data-react-helmet="true" name="description" content="什么是ES6？ES6和JS有什么区别？"><meta data-react-helmet="true" property="og:description" content="什么是ES6？ES6和JS有什么区别？"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://lrqwriting.top/docs/note/前端笔记1"><link data-react-helmet="true" rel="alternate" href="https://lrqwriting.top/en/docs/note/前端笔记1" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://lrqwriting.top/docs/note/前端笔记1" hreflang="zh-cn"><link data-react-helmet="true" rel="alternate" href="https://lrqwriting.top/docs/note/前端笔记1" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://ZABUFQBOIA-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.22bcbf3e.css">
<link rel="preload" href="/assets/js/runtime~main.8244c0ce.js" as="script">
<link rel="preload" href="/assets/js/main.9f02d018.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">主页</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">文章</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/RainMaker-Q" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_1Doo"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/intro">欢迎来到我的博客！</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">前端零食</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">算法</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">项目玩耍</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">乱七八糟</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">学习笔记</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/Java学习笔记">学习Java</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript">你不知道的JavaScript(1)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript2">你不知道的JavaScript(2)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript3">你不知道的JavaScript(3)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript中1">你不知道的JavaScript(中卷)1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript中2">你不知道的JavaScript (中卷)2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/前端杂笔记">前端杂笔记</a></li><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/note/前端笔记1">前端笔记(合集)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/学习HTTP协议">学习HTTP协议</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/学习css的flex布局">学习css的flex布局</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/学习webpack">学习Webpack</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">一些动效</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1>前端笔记(合集)</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="什么是es6es6和js有什么区别"></a>什么是ES6？ES6和JS有什么区别？<a class="hash-link" href="#什么是es6es6和js有什么区别" title="Direct link to heading">#</a></h3><p>ES6是一个标准，全名是ECMAScript6.0，而JavaScript是ES6的一个实现。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="什么是commonjs和nodejs为什么会有它们"></a>什么是CommonJS和NodeJS？为什么会有它们？<a class="hash-link" href="#什么是commonjs和nodejs为什么会有它们" title="Direct link to heading">#</a></h3><p>commonjs是一种规范，nodejs是这种规范的实现。
JavaScript的标准定义API是为了<strong>用于构建基于浏览器的应用程序</strong>，但是没有一个用于更广泛的应用程序的标准库。<strong>最初的JavaScript只能用来给浏览器使用。</strong>
而CommonJS API定义了很多普通应用程序使用的API，从而填补了这个空白。它的究极目标是提供一个类似Python、Ruby和Java的标准库。这样开发者就可以使用CommonJs API来编写程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="javascript和nodejs的区别是什么"></a>JavaScript和NodeJs的区别是什么？<a class="hash-link" href="#javascript和nodejs的区别是什么" title="Direct link to heading">#</a></h3><p>JavaScript：</p><ul><li>ECMAScript（语言基础，如语法、数据类型结构、以及一些内置对象）</li><li>DOM（一些操作页面元素的方法）</li><li>BOM（一些操作浏览器的方法）</li></ul><p>NodeJS：</p><ul><li>ECMAScript（语言基础，如语法、数据类型结构、以及一些内置对象）</li><li>os（操作系统）</li><li>file（文件系统）</li><li>net（网络系统）</li><li>database（数据库）</li></ul><p>总结：前端和后端js的共同点就是，他们的语言基础都是ECMAScript，只是他们扩展的东西不同，前端需要操作页面元素，于是扩展了DOM，也需要操作浏览器，于是扩展了BOM。而服务端的js则也是基于ECMAScript扩展出了服务端所需要的一些API。常见的后台语言需要有操作系统的能力，于是扩展了os，需要有操作文件的能力，于是扩展了file文件系统，需要操作网络，于是扩展出了net网络系统，需要操作数据，于是扩展出了database能力。</p><hr><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="函数执行中的理解"></a>函数执行中的理解<a class="hash-link" href="#函数执行中的理解" title="Direct link to heading">#</a></h3><ol><li>进入执行上下文，激活变量对象VO，变为活动对象AO(Activation object)</li><li>AO对象默认初始化arguments对象，存有函数形参。</li><li>进入执行上下文后，将函数内的变量、函数解析到AO中，函数中的形参在AO中存值，函数内的实参在AO中是undefined，然后顺序执行代码，一步一步给AO中的参数赋值。</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="js中堆与栈的使用"></a>JS中堆与栈的使用<a class="hash-link" href="#js中堆与栈的使用" title="Direct link to heading">#</a></h3><p>JS中基本类型保存在栈内存中，因为这些类型再内存中分别占有固定大小的空间，通过按值访问。引用类型保存在堆内存中，因为这种值的大小不固定，因此不能保存在栈内存中，但是内存地址大小是固定的，可以将地址放在栈中。
查找引用类型的值时，先去栈中查找，读取内存地址，再通过地址找到堆内存中的值。</p><p>小青离京，好好学习~</p><hr><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="由一个小问题分析js的赋值问题"></a>由一个小问题分析JS的赋值问题<a class="hash-link" href="#由一个小问题分析js的赋值问题" title="Direct link to heading">#</a></h3><p><strong>问题</strong></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var a = {n: 1};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var b = a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.x = a = {n:2};    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(a.x);   //输出是undefined</span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(b.x);   //输出是{n: 2}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>重点</strong></p><ul><li>JS引擎对<strong>赋值表达式</strong>的处理过程</li><li>赋值运算的<strong>右结合性</strong></li></ul><p>JS引擎怎么计算赋值表达式呢 比如A = B</p><ol><li>计算表达式A，得到一个引用refA</li><li>计算表达式B，得到一个值valueB</li><li>将valueB赋给refA指向的名称绑定</li><li>返回valueB</li></ol><p>右结合性
所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的
赋值表达式是右结合的,也就是说：
A1 = A2 = A3 = A4
等价于
A1 = (A2 = (A3 = A4))</p><p>所以，表达式是从左往右找到引用，从右往左进行赋值
当JS引擎运行到a.x = a = {n:2};时，从左往右求引用，a.x的引用是在{n:1,x:undefined}的x,a的引用是对象{n:1}。从右往左求值，a指向{n:2},b.x指向{n:2},b的地址还是原先a对象处的地址</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="闭包的变量并不是保存在栈内存中而是保存在堆内存中"></a>闭包的变量并不是保存在栈内存中，而是保存在堆内存中<a class="hash-link" href="#闭包的变量并不是保存在栈内存中而是保存在堆内存中" title="Direct link to heading">#</a></h4><p>闭包的简单定义：函数A返回了一个函数B，并且函数B中引用了函数A的变量。函数B就称为闭包。</p><p><strong>typeof(null)是object，可以将引用变量赋值为null。typeof(undefined)为undefined。</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="垃圾回收算法"></a>垃圾回收算法<a class="hash-link" href="#垃圾回收算法" title="Direct link to heading">#</a></h3><ol><li>引用计数法：看一个对象是否有指向它的引用。  弊端：循环引用导致内存泄露。</li><li>标记清除法：从根部(JS中为全局对象)出发，定时扫描内存中的对象，能从根部到达的对象，都是还需要使用的。无法从根部到达的对象，标记为不再使用，稍后进行回收。</li></ol><ul><li>经验法则：连续五次垃圾回收之后，内存占用一次比一次大，就存在内存泄露。  </li></ul><hr><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="初始定义的模块"></a>初始定义的模块<a class="hash-link" href="#初始定义的模块" title="Direct link to heading">#</a></h3><p>在NodeJs中，编写稍大一点的程序时一般会将代码模块化，将代码合理拆分到不同的JS文件中，每一个文件都是一个模块，文件路径就是模块名。
编写每个模块时，都有require、exports、module三个预定义好的变量可以使用。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="require模块"></a>require模块<a class="hash-link" href="#require模块" title="Direct link to heading">#</a></h4><p>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可以用相对路径，或者绝对路径，模块名中的.js后缀也可以省略。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var foo1 = require(&#x27;./foo&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var foo2 = require(&#x27;./foo.js&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var foo3 = require(&#x27;/home/usr/foo&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var foo4 = require(&#x27;/home/usr/foo.js&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">以上四个变量都是同一个模块的导出对象</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="exports模块"></a>exports模块<a class="hash-link" href="#exports模块" title="Direct link to heading">#</a></h4><p>exports对象使当前模块的导出对象，用于导出模块共有方法和属性。别的模块通过require函数使用当前模块时，就是当前模块的exports对象。如:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">exports.hello = function(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;Hi~&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="module模块"></a>module模块<a class="hash-link" href="#module模块" title="Direct link to heading">#</a></h4><p>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="主模块"></a>主模块<a class="hash-link" href="#主模块" title="Direct link to heading">#</a></h4><p>通过命令行参数传递给NodeJs启动的模块被称为主模块。主模块负责调度组成整个程序的其他模块完成工作。
当主模块中使用require函数之后，导入该模块。在内存空间中生成该引入模块的对象，就算在主模块中使用不同的变量反复导入统一模块，此模块也只初始化一次。只不过新声明的变量也指向第一次生成的对象。</p><hr><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="代码的组织和部署"></a>代码的组织和部署<a class="hash-link" href="#代码的组织和部署" title="Direct link to heading">#</a></h3><p>JS模块的基本单位是单个JS文件，但复杂些的模块往往是由多个子模块组成。为了便于管理和使用，可以把由多个子模块组成的大模块称作包，并把所有子模块放在同一个目录中。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="indexjs"></a>index.js<a class="hash-link" href="#indexjs" title="Direct link to heading">#</a></h4><p>当模块的文件名是index.js时，加载模块时可以使用模块所在目录的路径代替模块文件路径。以下两条语句等价。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var cat = require(&#x27;/home/usr/lib/cat&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var cat = require(&#x27;/home/usr/lib/cat/index&#x27;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样处理之后，只需要把包目录路径传递给require函数，感觉上整个目录被当做单个模块使用，更有整体感。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="packagejson"></a>package.json<a class="hash-link" href="#packagejson" title="Direct link to heading">#</a></h4><p>使用package.json文件，就可以<strong>自定义入口模块的文件名和存放位置，</strong>并在其中指定入口模块的路径。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;name&quot;:&quot;cat&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;main&quot;:&quot;./lib/main.js&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>定义好package.js文件之后，就可以使用require(&#x27;home/user/lib/cat&#x27;)的方式加载模块(这次入口文件不是index.js,也是直接引用的包目录的路径),NodeJs会根据包目录下的package.json找到入口模块所在位置。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="命令行程序"></a>命令行程序<a class="hash-link" href="#命令行程序" title="Direct link to heading">#</a></h4><p>使用NodeJs编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。如果在部署代码的时候用一些技巧，就可以让用户觉得自己是在使用一个命令行程序。
<strong>Linux下</strong></p><ol><li>可以把JS文件当做shell脚本来运行,在编写完成的js程序第一行加上</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">#!/usr/bin/env node</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="2"><li>然后赋予该js文件可执行的权限(node-echo.js是文件名，该文件的路径时/home/user/bin)</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">chmod +x /home/user/bin/node-echo.js</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="3"><li>在PATH环境变量中指定的某个目录下，例如在/usr/local/bin中创建一个软链文件，文件名与我们希望使用的终端命令同名</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样处理以后，我们就可以在任何目录下使用node-echo命令了</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="工程目录"></a>工程目录<a class="hash-link" href="#工程目录" title="Direct link to heading">#</a></h4><p>一个完整的工程目录，应该提供命令行模式和API模式两种使用方式，并且我们会借助第三方包来编写代码。除了代码以外，一个完整的程序还应该有自己的文档和测试用例。如下:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">-/home/usr/workspace/node-echo/   #工程目录</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -bin/       #存放命令行相关代码</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        node-echo</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    +doc/       #存放文档</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -lib/       #存放API相关代码</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        echo.js</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -node_modules/  #存放三方包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        + argv/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    +tests/     #存放测试用例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    package.json    #元数据文件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    README.md       #说明文件</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>不同的文件夹存放了不同类型的文件，并通过node_modules目录直接使用三方包名加载模块。此外，定义了package.json之后，node-echo目录也可以被当做一个包来使用。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="使用npm的一些东西"></a>使用npm的一些东西<a class="hash-link" href="#使用npm的一些东西" title="Direct link to heading">#</a></h4><ol><li>可以上<strong>npmjs.org</strong>来搜索自己想要的包</li><li>npm install是下载最新版本的包，如果想下载指定版本的话，可以加@符号，比如
<strong>npm install <a href="mailto:vue@0.0.1" target="_blank" rel="noopener noreferrer">vue@0.0.1</a></strong></li><li>当引入的三方包比较多时，可以在package.json中添加依赖项，然后在工程目录中使用<strong>npm install</strong>,会自动安装所依赖的包。</li><li>npm install node-echo -g，为例，-g表示全局安装，安装之后NPM会自动创建好Linux系统需要的软链文件或Windows系统下的.cmd文件。
在linux系统下，会安装到<strong>/usr/local/lib/node_modules/</strong>这里，并且在<strong>/usr/local/bin/</strong>这里创建软链。</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="语义版本号"></a>语义版本号<a class="hash-link" href="#语义版本号" title="Direct link to heading">#</a></h4><p>npm使用语义版本号来管理代码，语义版本号分为X.Y.Z三位，分别代表主版本号，次版本号和补丁版本号。当代码变更时，版本号按以下原则进行更新。</p><ul><li>如果只是修复了bug，需要更新Z位</li><li>如果是新增了功能，但是向下兼容，需要更新Y位</li><li>如果有大变动，向下不兼容，需要更新X位</li></ul><hr><p>今天看了promise，一直在说promise是js的实现异步操作的解决方案。中间说了很多事件循环机制，就查了查。看到一篇博客，写的不错，很便于理解。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="消息队列"></a>消息队列<a class="hash-link" href="#消息队列" title="Direct link to heading">#</a></h4><ul><li>有些文章把消息队列称为任务队列，或者叫事件队列，总之是和异步任务相关的队列</li><li>可以确定的是，它是队列这种先入先出的数据结构，和排队是类似的，哪个异步操作完成的早，就排在前面。不论异步操作何时开始执行，只要异步操作执行完成，就可以到消息队列中排队</li><li>这样，主线程在空闲的时候，就可以从消息队列中获取消息并执行
*消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关。但是为了简单起见，可以认为：消息就是注册异步任务时添加的回调函数。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="事件循环"></a>事件循环<a class="hash-link" href="#事件循环" title="Direct link to heading">#</a></h4><p>下面来详细介绍事件循环。下图中，主线程运行的时候，产生堆和栈，栈中的代码调用各种外部API，异步操作执行完成后，就在消息队列中排队。只要栈中的代码执行完毕，主线程就会去读取消息队列，依次执行那些异步任务所对应的回调函数
<img src="https://github.com/LRQLRQ/picture/blob/master/eventloop.png?raw=true" alt="avatar"></p><p>详细步骤如下：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个&quot;消息队列&quot;。只要异步操作执行完成，就到消息队列中排队</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面的第三步</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="循环"></a>循环<a class="hash-link" href="#循环" title="Direct link to heading">#</a></h4><p>从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。</p><p>由于主线程不断的重复获得消息、执行消息、再取消息、再执行。所以，这种机制被称为事件循环</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="事件"></a>事件<a class="hash-link" href="#事件" title="Direct link to heading">#</a></h4><p>　　为什么叫事件循环？而不叫任务循环或消息循环。究其原因是消息队列中的每条消息实际上都对应着一个事件</p><p>　　DOM操作对应的是DOM事件，资源加载操作对应的是加载事件，而定时器操作可以看做对应一个“时间到了”的事件</p><hr><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="背景"></a>背景<a class="hash-link" href="#背景" title="Direct link to heading">#</a></h3><p>昨天在写代码的时候用到了v-model,出现了一点问题。我在vue的data中定义了一个空的对象<code>obj: {}</code>,在某个ajax操作中会对这个对象进行操作，赋予很多属性，比如说 <code>obj.name = &#x27;lrq&#x27;</code>。在html中我将这个属性绑定在一个input输入框中<code>&lt;input v-model=&quot;obj,name&quot;&gt;</code>，但是没有达到想要的效果，前端页面既没有显示数据，console打印出来的数据也是空。<strong>解决方案</strong>：在定义obj对象的时候要直接加上这个属性，就可以监听到变化了。 <code>obj: {name: &#x27;&#x27;}</code>.借着这个机会深入了解一下vue的双向绑定。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="什么是双向绑定"></a>什么是双向绑定?<a class="hash-link" href="#什么是双向绑定" title="Direct link to heading">#</a></h3><p>v-model实现的功能就是双向绑定，前端页面的dom元素和js中的数据进行绑定。当前端元素，比如说是一个input输入框，内容发生改变后，相应的js中与之相关的数据也会发生改变。同理，当js中处理一些业务逻辑后，对数据进行了修改，前端页面中的input输入框的内容也会发生变化。这就是双向绑定。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="双向绑定是怎么实现的"></a>双向绑定是怎么实现的?<a class="hash-link" href="#双向绑定是怎么实现的" title="Direct link to heading">#</a></h3><ol><li>dom元素内容发生变化，会触发相应的事件。比如说input元素的<code>onchange</code>、<code>oninput</code>事件，可以在事件中进行js中数据的同步修改。</li><li>而js中的数据修改之后，怎么反映到dom元素中呢?这里用到了数据劫持。非常细节的底层现在我也还不是很懂，但大概的流程基本知道了。首先在初始化数据的时候要使用Object.defineProperty()方法重写数据的set和get方法，在实际的使用中，给数据赋值实际上就是调用了set方法，这样就可以在set方法中进行一些操作，比如说把set后的value直接写到前端的页面中，进而达到js中数据改变关联到前端页面同步改变的效果。</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="v-model的语法糖"></a>v-model的语法糖<a class="hash-link" href="#v-model的语法糖" title="Direct link to heading">#</a></h3><p>v-model相当于是一个语法糖，比如以下代码</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;input type=&quot;text&quot; v-model=&quot;suger&quot;&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;input type=&quot;text&quot; v-bind:value=&quot;suger&quot;  v-on:input=&quot;$event.target.value&quot;&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这两段代码产生的效果是一样的，这就是语法糖的意思。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="需要进一步了解的东西"></a>需要进一步了解的东西<a class="hash-link" href="#需要进一步了解的东西" title="Direct link to heading">#</a></h3><p>看了很多博客，说是在数据劫持中使用了发布者订阅者模式，具体的看了一些还是不太清晰，日后再好好看一下，再回来补充。</p><hr></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/note/前端杂笔记"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 前端杂笔记</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/note/学习HTTP协议"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">学习HTTP协议 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#什么是es6es6和js有什么区别" class="table-of-contents__link">什么是ES6？ES6和JS有什么区别？</a></li><li><a href="#什么是commonjs和nodejs为什么会有它们" class="table-of-contents__link">什么是CommonJS和NodeJS？为什么会有它们？</a></li><li><a href="#javascript和nodejs的区别是什么" class="table-of-contents__link">JavaScript和NodeJs的区别是什么？</a></li><li><a href="#函数执行中的理解" class="table-of-contents__link">函数执行中的理解</a></li><li><a href="#js中堆与栈的使用" class="table-of-contents__link">JS中堆与栈的使用</a></li><li><a href="#由一个小问题分析js的赋值问题" class="table-of-contents__link">由一个小问题分析JS的赋值问题</a></li><li><a href="#垃圾回收算法" class="table-of-contents__link">垃圾回收算法</a></li><li><a href="#初始定义的模块" class="table-of-contents__link">初始定义的模块</a></li><li><a href="#代码的组织和部署" class="table-of-contents__link">代码的组织和部署</a></li><li><a href="#背景" class="table-of-contents__link">背景</a></li><li><a href="#什么是双向绑定" class="table-of-contents__link">什么是双向绑定?</a></li><li><a href="#双向绑定是怎么实现的" class="table-of-contents__link">双向绑定是怎么实现的?</a></li><li><a href="#v-model的语法糖" class="table-of-contents__link">v-model的语法糖</a></li><li><a href="#需要进一步了解的东西" class="table-of-contents__link">需要进一步了解的东西</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Blog, Inc.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8244c0ce.js"></script>
<script src="/assets/js/main.9f02d018.js"></script>
</body>
</html>