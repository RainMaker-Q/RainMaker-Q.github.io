<!doctype html>
<html lang="zh-cn" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Rain-Maker的成长之路 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Rain-Maker的成长之路 Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Rain-Maker的成长之路" href="/opensearch.xml"><title data-react-helmet="true">你不知道的JavaScript(2) | Rain-Maker的成长之路</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://lrqwriting.top/docs/note/你不知道的JavaScript2"><meta data-react-helmet="true" name="docsearch:language" content="zh-cn"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="你不知道的JavaScript(2) | Rain-Maker的成长之路"><meta data-react-helmet="true" name="description" content="块级作用域"><meta data-react-helmet="true" property="og:description" content="块级作用域"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://lrqwriting.top/docs/note/你不知道的JavaScript2"><link data-react-helmet="true" rel="alternate" href="https://lrqwriting.top/en/docs/note/你不知道的JavaScript2" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://lrqwriting.top/docs/note/你不知道的JavaScript2" hreflang="zh-cn"><link data-react-helmet="true" rel="alternate" href="https://lrqwriting.top/docs/note/你不知道的JavaScript2" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://ZABUFQBOIA-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.22bcbf3e.css">
<link rel="preload" href="/assets/js/runtime~main.8244c0ce.js" as="script">
<link rel="preload" href="/assets/js/main.9f02d018.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">主页</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">文章</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/RainMaker-Q" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_1Doo"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/intro">欢迎来到我的博客！</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">前端零食</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">算法</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">项目玩耍</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">乱七八糟</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">学习笔记</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/Java学习笔记">学习Java</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript">你不知道的JavaScript(1)</a></li><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/note/你不知道的JavaScript2">你不知道的JavaScript(2)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript3">你不知道的JavaScript(3)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript中1">你不知道的JavaScript(中卷)1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/你不知道的JavaScript中2">你不知道的JavaScript (中卷)2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/前端杂笔记">前端杂笔记</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/前端笔记1">前端笔记(合集)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/学习HTTP协议">学习HTTP协议</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/学习css的flex布局">学习css的flex布局</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/note/学习webpack">学习Webpack</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">一些动效</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1>你不知道的JavaScript(2)</h1></header><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="块级作用域"></a>块级作用域<a class="hash-link" href="#块级作用域" title="Direct link to heading">#</a></h5><p>先说一段代码</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var foo = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if(foo) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var bar = foo * 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(bar);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(bar);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>上述代码会输出什么呢？我一直以为第一个console输出2，到第二个会输出undefined，但是两个都输出了2.就是因为定义的时候用的是var！！使用var声明变量时，bar在哪里都是一样的，最终都会属于外部作用域。<br>
const 和 let有块级作用域，var出来的变量没有块级作用域。</p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="小结"></a>小结<a class="hash-link" href="#小结" title="Direct link to heading">#</a></h5><ol><li>函数是JavaScript中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</li><li>函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常是指{ .. }内部)</li><li>从ES3开始，try/catch结构在 catch分句中具有块作用域。</li><li>在ES6中引入了<code>let</code>关键字(<code>var</code>关键字的表亲),用来在任意代码块中声明变量。if( .. ){ let a = 2; }会声明一个劫持了if的 { .. }块的变量，并且将变量添加到这个块中。</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="提升"></a>提升<a class="hash-link" href="#提升" title="Direct link to heading">#</a></h3><p>编译：引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来。<br>
<strong>只有声明本身会被提升，而赋值操作或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的后果</strong><br>
函数声明会被提升，但是函数表达式却不会被提升。  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">foo();  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">var foo = function bar() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>上面这种就是函数表达式，  变量标识符<code>foo()</code>被提升并分配给所在作用域，因此<code>foo()</code>不会导致ReferenceError。但是foo此时没有赋值，(如果他是一个函数声明而不是函数表达式，就会被赋值),程序运行到foo()时，foo的内容还是undefined，对undefined进行调用导致非法操作，因此会抛出TypeError异常。<br>
此外，即使是具名的函数表达式，名称标识符在赋值之前也无法再所在作用域中使用：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">foo();  //TypeError</span></span><span class="token-line" style="color:#393A34"><span class="token plain">bar();  //ReferenceError</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var foo = function bar() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>上段代码提升后，实际上会理解为以下形式:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var foo;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo();  //TypeError</span></span><span class="token-line" style="color:#393A34"><span class="token plain">bar();  //ReferenceError</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo = function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var bar = ...self...;   //其实我也不太懂</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="函数优先"></a>函数优先<a class="hash-link" href="#函数优先" title="Direct link to heading">#</a></h4><p>函数声明和变量声明都会被提升，但是两者同时呢？答案是函数会首先被提升，然后才是变量。  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">foo();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var foo;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function foo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;1&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo = function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;2&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>输出的结果是1，而不是2. <code>var foo</code>尽管出现在<code>function foo()...</code>的声明之前，但它是重复的声明，被忽略了，因为函数的声明会被提升到普通变量之前。  </p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="作用域闭包"></a>作用域闭包<a class="hash-link" href="#作用域闭包" title="Direct link to heading">#</a></h3><p>闭包是基于词法作用域书写代码时所产生的自然结果，甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用值代码中随处可见，<strong>缺少的是根据自己的意愿来识别、拥抱、和影响闭包的思维环境。</strong><br>
闭包定义：<strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行</strong><br>
引擎有垃圾回收器来释放不再使用的内存空间，但是闭包可以阻止这件事的发生。内部作用域依然存在，闭包的哪个引用，仍然在使用内部作用域的某个变量。<br>
某个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。无论通过何种手段将内部函数传递到所在的词法作用域以外，<strong>它都会持有对原始定义作用域的引用</strong>，无论在何处执行这个函数都会使用闭包。  </p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="模块"></a>模块<a class="hash-link" href="#模块" title="Direct link to heading">#</a></h4><p>先看一块代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function CoolModule() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var something = &quot;cool&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var another = [1, 2, 3];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    function doSomething() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        console.log( something );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    function doAnother() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        console.log( another.join(&quot;!&quot;) );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        doSomething: doSomething,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        doAnother: doAnother</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var foo = CoolModule();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo.doSomething();      //cool</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo.doAnother();        //1!2!3!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>模块模式需要具备两个必要条件：</p><ol><li>必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以返回或者修改私有的状态。  </li></ol><p>一个具有函数属性的对象本身并不是真正的模块，从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。<br>
模块内部的函数也可以改动，如下代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var foo = (function CoolModule(id) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    function change() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 修改公共API</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publicAPI.identify = identify2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    function identify1() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        console.log( id );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    function identify2() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        console.log( id.toUpperCase() );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var publicAPI = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        change: change,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        identify: identify1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return publicAPI;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">})( &quot;foo module&quot; );</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo.identify(); // foo module</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo.change();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo.identify(); //FOO MODULE </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改他们的值。</p><p>贴一个模块管理器的代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var MyModules = (function Manager() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    var modules = {};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    function define(name, deps, impl) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(var i=0; i&lt;deps.length; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            deps[i] = module[deps[i]];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        modules[name] = impl.apply( impl, deps );  //这句话很关键</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    function get(name) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return modules[name];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        define: define,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        get: get</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">})();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>那句关键的话，为了模块的定义引入了包装函数，(可以传入任何依赖)，并且将返回值，也就是模块的API，存储在一个根据名字来管理的列表中。<br>
模块管理器没有任何的&quot;魔力&quot;，他们符合前面说的模块模式的两个特点：<strong>为函数定义引入包装函数，并保证它的返回值和模块的API保持一致。</strong>  </p><p>词法作用域和动态作用域的区别：  </p><ol><li>词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this 也是)</li><li>词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="第二章-this和原型对象"></a>第二章 this和原型对象<a class="hash-link" href="#第二章-this和原型对象" title="Direct link to heading">#</a></h2><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="误解"></a>误解<a class="hash-link" href="#误解" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="1指向自身"></a>1.指向自身<a class="hash-link" href="#1指向自身" title="Direct link to heading">#</a></h5><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="2指向它的作用域"></a>2.指向它的作用域<a class="hash-link" href="#2指向它的作用域" title="Direct link to heading">#</a></h5><p>在某种情况下它是正确的，但是在其他情况下它确实错误的。 <code>this</code>在任何情况下都不指向函数的词法作用域。在JavaScript内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域&quot;对象&quot;无法通过JavaScript代码访问，他存在于JavaScript引擎内部。  </p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="this到底是什么"></a>this到底是什么<a class="hash-link" href="#this到底是什么" title="Direct link to heading">#</a></h5><p>this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>
当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会记录函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到。<br>
<strong>this既不指向函数自身，也不指向函数的词法作用域，this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</strong>  </p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="调用位置"></a>调用位置<a class="hash-link" href="#调用位置" title="Direct link to heading">#</a></h4><p>调用位置是函数在代码中被调用的位置（而不是声明的位置）。要分析调用栈(就是为了到达当前的执行位置所调用的所有函数)。我们关心的调用位置就是当前正在执行的函数的前一个调用中。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="调用规则"></a>调用规则<a class="hash-link" href="#调用规则" title="Direct link to heading">#</a></h4><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="1-默认绑定"></a>1. 默认绑定<a class="hash-link" href="#1-默认绑定" title="Direct link to heading">#</a></h5><p>独立函数调用。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function foo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log( this.a );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var a = 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>tip</strong>：声明在全局作用域中的变量(比如var a = 2)就是全局对象的一个同名属性。当调用foo()时，this.a被解析成了全局变量a。因为在本例中，函数调用时应用了this的<code>默认绑定</code>，因此this指向全局对象。
如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此this会绑定到undefined。有时候写代码可能会用到第三方的库，其严格程度和你写的代码有所不同，要注意这类兼容性细节。</p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="2-隐式绑定"></a>2. 隐式绑定<a class="hash-link" href="#2-隐式绑定" title="Direct link to heading">#</a></h5><p>需要考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function foo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log( this.a );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    foo: foo</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var bar = obj.foo;  //函数别名</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var a = &quot;global&quot;;   //a是全局对象的属性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">bar();               //&quot;global&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>参数传递其实是一种隐式赋值。回调函数丢失this绑定是非常常见的。除此之外，还有一种情况this也会令人出乎意料：调用回调函数的函数可能会修改this</p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="3-显式绑定"></a>3. 显式绑定<a class="hash-link" href="#3-显式绑定" title="Direct link to heading">#</a></h5><p>在<strong>隐式绑定</strong>中，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性简介引用函数，从而把<code>this</code>间接(隐式)绑定到这个对象上。  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function foo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log( this.a );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">foo.call( obj )     //2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>通过<code>foo.call(...)</code>，我们可以在调用foo时强制把它的this绑定到obj上。<br>
如果传入的是一个原始值(字符串类型、布尔类型或者数字类型)来当做this的绑定对象，这个原始值会被转换成它的对象形式。（也就是 new String(..) 、 new Boolean(..) 或者 new Number(..) ）。这通常被称为&quot;装箱&quot;  .</p><h6><a aria-hidden="true" tabindex="-1" class="anchor anchor__h6 anchorWithStickyNavbar_31ik" id="硬绑定"></a>硬绑定<a class="hash-link" href="#硬绑定" title="Direct link to heading">#</a></h6><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function foo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log( this.a );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var bar = function() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    foo.call(obj);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">bar();  // 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">setTimeout( bar, 100)   // 2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>创建了函数bar(),并在它的内部手动调用了foo.call(obj), 因此强制把foo的this绑定到了obj， 无论之后如何调用函数bar，他们总会手动在obj上调用foo，这种绑定是一种显示的强制绑定，因此我们称为硬绑定。<br>
<code>硬绑定</code>是一种非常常用的模式，在ES5中提供了内置的方法<code>Function.prototype.bind</code>,它的用法如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function foo(something) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log( this.a , something);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.a + something;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var bar = foo.bind( obj );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var b = bar(3);     // 2 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log( b );   //5</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>bind(..)会返回一个硬编码的新函数，它会把参数设置为this的上下文并调用原始函数。  </p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="4-new绑定"></a>4. new绑定<a class="hash-link" href="#4-new绑定" title="Direct link to heading">#</a></h5><p>使用new来调用函数，或者说发生都早函数调用时，会自动执行下面的操作：</p><ol><li>创建（或者说构造）一个全新的对象</li><li>这个新对象会被执行 [[原型 ]]连接。</li><li>这个新对象会绑定到函数调用的this</li><li>如果哈数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function foo(a) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.a = a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var bar = new foo(2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log( bar.a );   //2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="优先级"></a>优先级<a class="hash-link" href="#优先级" title="Direct link to heading">#</a></h4><p>有些地方多条规则都可以用，就得讨论一下优先级了。&quot;默认绑定&quot;这个弟弟肯定是优先级最低的了。</p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="显式绑定和隐式绑定优先级比较"></a>显式绑定和隐式绑定优先级比较<a class="hash-link" href="#显式绑定和隐式绑定优先级比较" title="Direct link to heading">#</a></h5><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function foo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log( this.a );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj1 = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    foo: foo</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var obj2 = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 3,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    foo: foo</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">obj1.foo();             //2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">obj2.foo();             //3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">obj1.foo.call( obj2 );  //3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">obj2.foo.call( obj1 );  //2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>显示绑定</strong>优先级更高，也就是说在判断时应当优先考虑是否可以应用<strong>显示绑定</strong>。</p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="判断this"></a>判断this<a class="hash-link" href="#判断this" title="Direct link to heading">#</a></h5><p>可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照以下顺序判断：</p><ol><li>函数是否在new中调用(new 绑定)？如果是的话，this绑定的对象是新创建的对象。<br><code>var bar = new foo();</code></li><li>函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。<br><code>var bar = foo.call( obj2 );</code></li><li>函数是否在某个上下文对象中调用(隐式绑定)？ 如果是的话，this绑定的是那个上下文对象。<br><code>var bar = obj1.foo();</code></li><li>如果都不是，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。<br><code>var bar = foo();</code></li></ol><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="被忽略的this"></a>被忽略的this<a class="hash-link" href="#被忽略的this" title="Direct link to heading">#</a></h5><p>如果你把null或者undefined作为this的绑定对象传入call。apply或者bind，这些值在调用时会被忽略，实际使用的是默认绑定规则。  </p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="this语法"></a>this语法<a class="hash-link" href="#this语法" title="Direct link to heading">#</a></h5><p>ES6中有一种无法使用这些规则的特殊函数类型：箭头函数。
箭头函数不是用function关键字定义的，而是使用被称为&quot;胖箭头&quot;的操作符 =&gt;定义的。箭头函数不使用this的四种标准规则，而是根据外层(函数或全局)作用域来决定this。  </p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="小结-1"></a>小结<a class="hash-link" href="#小结-1" title="Direct link to heading">#</a></h4><p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面的这四条规则来判断this的绑定对象。  </p><ol><li>由new 调用？  则绑定到新创建的对象。</li><li>由call 或者 apply (或者bind)调用？  绑定到指定的对象。</li><li>由上下文对象调用？  绑定到上下文对象</li><li>默认： 在严格模式下绑定到undefined，  否则绑定到全局对象。</li></ol><p><strong>ATTENTION</strong>：有些调用可能再无意中使用默认绑定规则。如果想&quot;更安全&quot;地忽略this绑定，可以使用一个DMZ对象，比如φ = Object.create(null),以保护全局对象。<br>
ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this。具体来说，箭头函数会继承外层函数调用的this绑定，(无论this绑定到什么)。这其实和ES6之前的代码中的self = this机制一样。  </p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="对象"></a>对象<a class="hash-link" href="#对象" title="Direct link to heading">#</a></h2><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="类型"></a>类型<a class="hash-link" href="#类型" title="Direct link to heading">#</a></h4><p>对象是JavaScript的基础。在JavaScript中一共有六种主要类型(术语是&quot;语言类型&quot;):<br>
string 、number 、boolean 、null 、undefined 、object
简单基本类型(string 、boolean 、number 、null 、undefined )本身并不是对象。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug，即对null执行 <code>typeof null</code> 会返回 <code>object</code>，实际上，null本身是基本类型。<br>
JavaScript中海油一些对象子类型，通常被称为内置对象，如： Strig、Number、Boolean、Object、Function、Array、Date、RegExp、Error  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var str = &quot;I am a string&quot; ;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log( str.length );      //13</span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log( str.charAt(3));    //&quot;m&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>原始值 <code>I am a string</code>并不是一个对象，他只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其转换为String对象。<br>
使用以上的方法，我们可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成String对象，所以可以访问属性和方法。  </p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="内容"></a>内容<a class="hash-link" href="#内容" title="Direct link to heading">#</a></h4><p>对象的内容是由一些存储在特定明明位置的(任意类型的)值组成的，称之为属性。存储在对象容器内部的是这些属性的名称，它们就像指针，(从技术角度来说就是引用)，指向这些值真正存储的位置。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var myObject = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">myObject.a;     //2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">myObject[&quot;a&quot;]   //2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>如果要访问myObject中a位置上的值，我们需要.操作符或者[]操作符。 .a 语法通常被称为&quot;属性访问&quot;，[&quot;a&quot;]语法通常被称为&quot;键访问&quot;。实际上访问的是同一个位置。这两种语法的主要区别在于.操作符要求属性名满足标识符的命名规范，而[&quot;..&quot;]语法可以接受任何UTF-8字符串作为属性名。比如 myObject[&quot;Super-Fun!&quot;]  </p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="属性与方法"></a>属性与方法<a class="hash-link" href="#属性与方法" title="Direct link to heading">#</a></h5><p>从技术角度来说，函数永远不会&quot;属于&quot;一个对象。每次访问对象的属性就是属性访问，如果属性访问返回的是一个函数，那它也并不是一个&quot;方法&quot;。属性访问返回的函数和其他的函数没有任何区别。除了可能发生隐式绑定：<strong>有些函数有this引用，有时候这些this确实会指向调用位置的对象引用，但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为this是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</strong>  </p><p><strong>复制对象</strong><br>
JSON安全的对象：也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">function anotherFunction() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //..</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var anotherObject = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    c: true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var anotherArray = [];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var myObject = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    b: anotherObject,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    c: anotherArray,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    d: anotherFunction</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var newObj = Object.assign( {}, myObject );</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>属性描述符</strong>  </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">var myObject = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  value:2,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  writable: true,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  enumerable: true,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  configurable: true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/note/你不知道的JavaScript"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 你不知道的JavaScript(1)</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/note/你不知道的JavaScript3"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">你不知道的JavaScript(3) »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#提升" class="table-of-contents__link">提升</a></li><li><a href="#作用域闭包" class="table-of-contents__link">作用域闭包</a></li><li><a href="#第二章-this和原型对象" class="table-of-contents__link">第二章 this和原型对象</a></li><li><a href="#对象" class="table-of-contents__link">对象</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Blog, Inc.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8244c0ce.js"></script>
<script src="/assets/js/main.9f02d018.js"></script>
</body>
</html>